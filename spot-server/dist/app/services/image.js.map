{"version":3,"sources":["../../../src/app/services/image.ts"],"names":["aws","multer","multerS3","model","fileFilter","req","file","cb","mimetype","Error","upload","storage","acl","s3","bucket","metadata","originalname","substr","key","json","JSON","parse","body","prefix","postId","commentId","filename","predictNsfw","imgUrl","predictNsfwLambda","params","FunctionName","Payload","stringify","image","lambda","invoke","promise"],"mappings":"AAEA,MAAOA,CAAAA,GAAP,KAAgB,eAAhB,CAIA,MAAOC,CAAAA,MAAP,KAAmB,QAAnB,CACA,MAAOC,CAAAA,QAAP,KAAqB,WAArB,CAaA,GAAIC,CAAAA,KAAJ,CASA,KAAMC,CAAAA,UAAU,CAAG,CAACC,GAAD,CAAWC,IAAX,CAAsBC,EAAtB,GAAkC,CACnD,GACED,IAAI,CAACE,QAAL,GAAkB,YAAlB,EACAF,IAAI,CAACE,QAAL,GAAkB,WADlB,EAEAF,IAAI,CAACE,QAAL,GAAkB,WAFlB,EAGAF,IAAI,CAACE,QAAL,GAAkB,YAJpB,CAKE,CACAD,EAAE,CAAC,IAAD,CAAO,IAAP,CACH,CAPD,IAOO,CACLA,EAAE,CAAC,GAAIE,CAAAA,KAAJ,CAAU,iDAAV,CAAD,CAA+D,KAA/D,CACH,CACF,CAXD,CAcA,KAAMC,CAAAA,MAAM,CAAGT,MAAM,CAAC,CACpBG,UADoB,CAEpBO,OAAO,CAAET,QAAQ,CAAC,CAChBU,GAAG,CAAE,aADW,CAEhBC,EAAE,CAAEb,GAAG,CAACa,EAFQ,CAGhBC,MAAM,CAAE,YAHQ,CAIhBC,QAAQ,CAAE,SAAUV,GAAV,CAAoBC,IAApB,CAA+BC,EAA/B,CAAwC,CAChDA,EAAE,CAAC,IAAD,CAAO,CAAES,YAAY,CAAEV,IAAI,CAACU,YAAL,CAAkBC,MAAlB,CAAyB,CAAzB,CAA4B,GAA5B,CAAhB,CAAP,CACH,CANe,CAOhBC,GAAG,CAAE,SAAUb,GAAV,CAAoBC,IAApB,CAA+BC,EAA/B,CAAwC,CAC3C,KAAMY,CAAAA,IAAI,CAAGC,IAAI,CAACC,KAAL,CAAWhB,GAAG,CAACiB,IAAJ,CAASH,IAApB,CAAb,CACA,GAAII,CAAAA,MAAM,CAAG,EAAb,CAIA,GAAIJ,IAAI,CAACK,MAAL,EAAeL,IAAI,CAACM,SAAxB,CAAmC,CAEjCF,MAAM,CAAG,SAAWJ,IAAI,CAACK,MAAhB,CAAyB,YAAzB,CAAwCL,IAAI,CAACM,SAA7C,CAAyD,GACnE,CAHD,IAGO,IAAIN,IAAI,CAACK,MAAT,CAAiB,CAEtBD,MAAM,CAAG,SAAWJ,IAAI,CAACK,MAAhB,CAAyB,YAAzB,CAAwCnB,GAAG,CAACqB,QAA5C,CAAuD,GACjE,CAHM,IAGA,CAELH,MAAM,CAAG,SAAWlB,GAAG,CAACqB,QAAf,CAA0B,GACpC,CAEDnB,EAAE,CAAC,IAAD,CAAOgB,MAAM,CAAGlB,GAAG,CAACqB,QAApB,CACH,CAzBe,CAAD,CAFG,CAAD,CAArB,CAgCA,cAAeC,CAAAA,WAAf,CAA2BC,MAA3B,CAA6D,CAG3D,MAAO,MAeR,CAGD,cAAeC,CAAAA,iBAAf,CAAiCD,MAAjC,CAA+D,CAC7D,GAAI,CAACA,MAAL,CAAa,CACX,MAAO,MACR,CAED,KAAME,CAAAA,MAAM,CAAG,CACbC,YAAY,CAAE,uBADD,CAEbC,OAAO,CAAEZ,IAAI,CAACa,SAAL,CAAe,CACtBC,KAAK,CAAEN,MADe,CAAf,CAFI,CAAf,CAOA,MAAO5B,CAAAA,GAAG,CAACmC,MAAJ,CAAWC,MAAX,CAAkBN,MAAlB,EAA0BO,OAA1B,EACR,CAED,cAAe,CAAE3B,MAAF,CAAUiB,WAAV,CAAuBE,iBAAvB,CAAf","sourcesContent":["\n\nimport aws from '@services/aws';\nimport axios from 'axios';\n\n// s3 upload\nimport multer from 'multer';\nimport multerS3 from 'multer-s3';\n\n// nsfwjs\n// import tf from '@tensorflow/tfjs-node';\n\n// config\nimport config from '@config/config';\n\n// TODO: check env\n// if  ( config.production ) {\n// tf.enableProdMode();\n// }\n// import nsfw from 'nsfwjs';\nlet model: any;\n// nsfw.load().then((m: any) => {\n// console.log('Nsfwjs Model Loaded');\n// model = m;\n// }, (err: any) => {\n// console.log('Error loading tensorflow model', err)\n// }); // To load a local model, nsfw.load('file:///Users/kevin/Documents/repos/spot/spot-server/src/nsfwModel/')\n\n// Only allow jpeg and png\nconst fileFilter = (req: any, file: any, cb: any) => {\n  if (\n    file.mimetype === 'image/jpeg' ||\n    file.mimetype === 'image/png' ||\n    file.mimetype === 'image/gif' ||\n    file.mimetype === 'image/webp'\n  ) {\n    cb(null, true);\n  } else {\n    cb(new Error('Invalid file type, Jpeg, Png, Gif, WebP allowed'), false);\n  }\n};\n\n// upload files to s3\nconst upload = multer({\n  fileFilter,\n  storage: multerS3({\n    acl: 'public-read',\n    s3: aws.s3,\n    bucket: 'spottables',\n    metadata: function (req: any, file: any, cb: any) {\n      cb(null, { originalname: file.originalname.substr(0, 255) });\n    },\n    key: function (req: any, file: any, cb: any) {\n      const json = JSON.parse(req.body.json);\n      let prefix = '';\n\n      // Create the name\n      // req.filename contains the id for the content\n      if (json.postId && json.commentId) {\n        // reply\n        prefix = 'posts/' + json.postId + '/comments/' + json.commentId + '/';\n      } else if (json.postId) {\n        // comment\n        prefix = 'posts/' + json.postId + '/comments/' + req.filename + '/';\n      } else {\n        // post\n        prefix = 'posts/' + req.filename + '/';\n      }\n\n      cb(null, prefix + req.filename);\n    }\n  })\n});\n\n//  predict if image is nsfw before the spot is made locally on the server\nasync function predictNsfw(imgUrl: string): Promise<boolean> {\n  // if the model was not loaded\n  // if ( !model || !imgUrl ) {\n  return false;\n  // }\n\n  // disable for now for memory concerns\n\n  // const pic = await axios.get(imgUrl, {\n  // responseType: 'arraybuffer',\n  // });\n  // Image must be in tf.tensor3d format\n  // you can convert image to tf.tensor3d with tf.node.decodeImage(Uint8Array,channels)\n  // const image = await tf.node.decodeImage(pic.data,3);\n  // const predictions = await model.classify(image);\n  // image.dispose(); // Tensor memory must be managed explicitly (it is not sufficient to let a tf.Tensor go out of scope for its memory to be released).\n  // check if porn or hentai\n  // return predictions[0].className === 'Porn' || predictions[0].className === 'Hentai';\n}\n\n//  predict if image is nsfw, using aws lambda after the spot is already made\nasync function predictNsfwLambda(imgUrl: string): Promise<any> {\n  if (!imgUrl) {\n    return false;\n  }\n\n  const params = {\n    FunctionName: 'nsfw-image-prediction',\n    Payload: JSON.stringify({\n      image: imgUrl\n    })\n  };\n\n  return aws.lambda.invoke(params).promise();\n}\n\nexport default { upload, predictNsfw, predictNsfwLambda };\n"],"file":"image.js"}