export default{addProfilePicture,getTags,addTagsToContent,generateLink,validContent,inRange};import shortid from"shortid";import badwords from"@services/badwords";import locations from"@services/locations";import posts from"@db/posts";import comments from"@db/comments";import accounts from"@db/accounts";import tags from"@db/tags";import*as CommentsError from"@exceptions/comments";import{COMMENTS_CONSTANTS}from"@constants/comments";import profileImages from"@helpers/profileImages";function validContent(content){if(content.length<COMMENTS_CONSTANTS.MIN_CONTENT_LENGTH||content.length>COMMENTS_CONSTANTS.MAX_CONTENT_LENGTH){return new CommentsError.InvalidCommentLength(400,COMMENTS_CONSTANTS.MIN_CONTENT_LENGTH,COMMENTS_CONSTANTS.MAX_CONTENT_LENGTH)}if(!/^[\x00-\x7F]*$/.test(content)){return new CommentsError.InvalidCommentContent(400)}if(badwords.checkProfanity(content)){return new CommentsError.InvalidCommentProfanity(400)}return null}function combineStrings(a,b){const aBuffer=Buffer.from(a);const bBuffer=Buffer.from(b);const result=Buffer.alloc(aBuffer.length);for(let i=0;i<aBuffer.length;i++){result[i]=aBuffer[i]^bBuffer[i]}return result.toString()}function stringToInt(str,lowerbound,upperbound){let result=0;for(let i=0;i<str.length;i++){result=result+str.charCodeAt(i)}return result%(upperbound-lowerbound)+lowerbound}async function getProfilePictureFromBucket(index){if(index===-1){return"op.png"}return profileImages[index%profileImages.length]}async function addProfilePicture(comments,postCreator){for(let i=0;i<comments.length;i++){let index;if(comments[i].account_id==postCreator){index=-1}else{index=stringToInt(combineStrings(comments[i].account_id,comments[i].post_id),0,profileImages.length*COMMENTS_CONSTANTS.PROFILE_COLORS_COUNT)}comments[i].profilePictureSrc=await getProfilePictureFromBucket(index%profileImages.length);comments[i].profilePicture=index%COMMENTS_CONSTANTS.PROFILE_COLORS_COUNT;delete comments[i].account_id}return comments}async function getTags(comments,accountId){for(let index=0;index<comments.length;index++){await tags.getTagsByCommentId(comments[index].id).then(async tagList=>{const tagObject={owned:false,numTagged:tagList.length,tagged:false,tags:[]};if(accountId==comments[index].account_id){tagObject.owned=true}if(tagList.map(t=>t.account_id).includes(accountId)){tagObject.tagged=true;await accounts.getAccountById(comments[index].account_id).then(account=>{tagObject.tagger=account[0].username},err=>{})}const tags=[];for(let tagIndex=0;tagIndex<tagList.length;tagIndex++){await accounts.getAccountById(tagList[tagIndex].account_id).then(account=>{tags.push({username:tagObject.owned||accountId==tagList[tagIndex].account_id?account[0].username:"",offset:tagList[tagIndex].offset})},err=>{})}tagObject.tags=tags;comments[index].tag=tagObject},err=>{})}return comments}async function addTagsToContent(commentId,accountId,commentAccountId,commentContent){let ret="";await tags.getTagsByCommentId(commentId).then(async tagList=>{const tagObject={owned:false,numTagged:tagList.length,tagged:false,tags:[]};if(accountId==commentAccountId){tagObject.owned=true}if(tagList.map(t=>t.account_id).includes(accountId)){tagObject.tagged=true;await accounts.getAccountById(commentAccountId).then(account=>{tagObject.tagger=account[0].username},err=>{})}const tags=[];for(let tagIndex=0;tagIndex<tagList.length;tagIndex++){await accounts.getAccountById(tagList[tagIndex].account_id).then(account=>{tags.push({username:tagObject.owned||accountId==tagList[tagIndex].account_id?account[0].username:"",offset:tagList[tagIndex].offset})},err=>{})}tagObject.tags=tags;let myindex=0;tagObject.tags.forEach(tag=>{ret+=commentContent.substring(myindex,tag.offset);ret+="@"+tag.username;myindex+=tag.offset});ret+=commentContent.substring(myindex,commentContent.length)},err=>{});return ret}async function generateLink(){let link;let exists;do{link=shortid.generate();exists=await comments.linkExists(link)}while(exists);return link}async function inRange(postId,latitude,longitude){return posts.getPostByIdNoAccount(postId).then(rows=>{if(rows.length<1){return false}const post=rows[0];const distance=locations.distanceBetween(post.latitude,post.longitude,latitude,longitude,"m");return distance<=COMMENTS_CONSTANTS.MAX_DISTANCE})}
//# sourceMappingURL=comments.js.map