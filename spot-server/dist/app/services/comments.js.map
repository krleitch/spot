{"version":3,"sources":["../../../src/app/services/comments.ts"],"names":["addProfilePicture","getTags","addTagsToContent","generateLink","validContent","inRange","shortid","badwords","locations","posts","comments","accounts","tags","CommentsError","COMMENTS_CONSTANTS","profileImages","content","length","MIN_CONTENT_LENGTH","MAX_CONTENT_LENGTH","InvalidCommentLength","test","InvalidCommentContent","checkProfanity","InvalidCommentProfanity","combineStrings","a","b","aBuffer","Buffer","from","bBuffer","result","alloc","i","toString","stringToInt","str","lowerbound","upperbound","charCodeAt","getProfilePictureFromBucket","index","postCreator","account_id","post_id","PROFILE_COLORS_COUNT","profilePictureSrc","profilePicture","accountId","getTagsByCommentId","id","then","tagList","tagObject","owned","numTagged","tagged","map","t","includes","getAccountById","account","tagger","username","err","tagIndex","push","offset","tag","commentId","commentAccountId","commentContent","ret","myindex","forEach","substring","link","exists","generate","linkExists","postId","latitude","longitude","getPostByIdNoAccount","rows","post","distance","distanceBetween","MAX_DISTANCE"],"mappings":"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","sourcesContent":["export default {\n  addProfilePicture,\n  getTags,\n  addTagsToContent,\n  generateLink,\n  validContent,\n  inRange\n};\n\nimport shortid from 'shortid';\n\n// services\nimport badwords from '@services/badwords';\nimport locations from '@services/locations';\nimport aws from '@services/aws';\n\n// db\nimport posts from '@db/posts';\nimport comments from '@db/comments';\nimport accounts from '@db/accounts';\nimport tags from '@db/tags';\n\n// error\nimport * as CommentsError from '@exceptions/comments';\n\n// constants\nimport { COMMENTS_CONSTANTS } from '@constants/comments';\n\n// sources\nimport profileImages from '@helpers/profileImages';\n\nfunction validContent(content: string): Error | null {\n  if (\n    content.length < COMMENTS_CONSTANTS.MIN_CONTENT_LENGTH ||\n    content.length > COMMENTS_CONSTANTS.MAX_CONTENT_LENGTH\n  ) {\n    return new CommentsError.InvalidCommentLength(\n      400,\n      COMMENTS_CONSTANTS.MIN_CONTENT_LENGTH,\n      COMMENTS_CONSTANTS.MAX_CONTENT_LENGTH\n    );\n  }\n\n  // Only ASCII characters allowed currently\n  // content field is setup as utf8mb4 so emoji can be added later\n  // eslint-disable-next-line no-control-regex\n  if (!/^[\\x00-\\x7F]*$/.test(content)) {\n    return new CommentsError.InvalidCommentContent(400);\n  }\n\n  if (badwords.checkProfanity(content)) {\n    return new CommentsError.InvalidCommentProfanity(400);\n  }\n\n  return null;\n}\n\n// Profile Pictures\n\n// Combine the 2 strings by xor them\nfunction combineStrings(a: string, b: string): string {\n  const aBuffer = Buffer.from(a);\n  const bBuffer = Buffer.from(b);\n  const result = Buffer.alloc(aBuffer.length);\n\n  for (let i = 0; i < aBuffer.length; i++) {\n    result[i] = aBuffer[i] ^ bBuffer[i];\n  }\n\n  return result.toString();\n}\n\n// Turn the string to an int [lowerbound, upperbound]\nfunction stringToInt(str: string, lowerbound: number, upperbound: number) {\n  let result = 0;\n  for (let i = 0; i < str.length; i++) {\n    result = result + str.charCodeAt(i);\n  }\n\n  // TODO: Can take a better look behind the math of this to ensure its actually random enough\n\n  return (result % (upperbound - lowerbound)) + lowerbound;\n}\n\nasync function getProfilePictureFromBucket(index: number) {\n  // TODO: REMOVE\n  // SAVE on requests to the bucket\n\n  if (index === -1) {\n    return 'op.png';\n  }\n\n  return profileImages[index % profileImages.length];\n\n  // This code should be moved somewhere else\n\n  // var params = {\n  //     Bucket: 'spot',\n  //     Delimiter: '/',\n  //     Prefix: 'profile/icons/',\n  // }\n\n  // const s3Response = await aws.s3.listObjectsV2(params).promise();\n\n  // if ( index === -1 ) {\n  //     return aws.getUrlFromBucket('profile/op.png');\n  // } else {\n  //     // the first index is a dud /profile/icons/\n  //     return aws.getUrlFromBucket(s3Response.Contents[index].Key);\n  // }\n}\n\nasync function addProfilePicture(comments: any, postCreator: string) {\n  for (let i = 0; i < comments.length; i++) {\n    let index;\n    if (comments[i].account_id == postCreator) {\n      index = -1;\n    } else {\n      index = stringToInt(\n        combineStrings(comments[i].account_id, comments[i].post_id),\n        0,\n        profileImages.length * COMMENTS_CONSTANTS.PROFILE_COLORS_COUNT\n      );\n    }\n\n    // Get the image and save the Index\n    comments[i].profilePictureSrc = await getProfilePictureFromBucket(\n      index % profileImages.length\n    );\n    comments[i].profilePicture =\n      index % COMMENTS_CONSTANTS.PROFILE_COLORS_COUNT;\n    delete comments[i].account_id;\n  }\n\n  return comments;\n}\n\n// Tags\n\nasync function getTags(comments: any, accountId: string): Promise<any[]> {\n  // get tags for each reply\n  for (let index = 0; index < comments.length; index++) {\n    await tags.getTagsByCommentId(comments[index].id).then(\n      async (tagList: any) => {\n        // The required properties\n        const tagObject: {\n          owned: boolean; // you own the tag\n          numTagged: number; // how many people were tagged\n          tagged: boolean; // you were  tagged\n          tagger?: string; // only filled if tagged == true, who the tagger is\n          tags: any[]; // list of the tags\n        } = {\n          owned: false,\n          numTagged: tagList.length,\n          tagged: false,\n          tags: []\n        };\n\n        if (accountId == comments[index].account_id) {\n          // You are the tagger\n\n          tagObject.owned = true;\n        }\n\n        if (tagList.map((t: any) => t.account_id).includes(accountId)) {\n          // you got tagged\n\n          tagObject.tagged = true;\n\n          await accounts.getAccountById(comments[index].account_id).then(\n            (account: any) => {\n              tagObject.tagger = account[0].username;\n            },\n            (err: any) => {}\n          );\n        }\n\n        // add the tags, only include username if you own tag, or its you\n        const tags: any[] = [];\n        for (let tagIndex = 0; tagIndex < tagList.length; tagIndex++) {\n          await accounts.getAccountById(tagList[tagIndex].account_id).then(\n            (account: any) => {\n              tags.push({\n                username:\n                  tagObject.owned || accountId == tagList[tagIndex].account_id\n                    ? account[0].username\n                    : '',\n                offset: tagList[tagIndex].offset\n              });\n            },\n            (err: any) => {}\n          );\n        }\n        tagObject.tags = tags;\n\n        comments[index].tag = tagObject;\n      },\n      (err: any) => {}\n    );\n  }\n\n  return comments;\n}\n\nasync function addTagsToContent(\n  commentId: string,\n  accountId: string,\n  commentAccountId: string,\n  commentContent: string\n): Promise<string> {\n  let ret = '';\n\n  await tags.getTagsByCommentId(commentId).then(\n    async (tagList: any) => {\n      // The required properties\n      const tagObject: {\n        owned: boolean;\n        numTagged: number;\n        tagged: boolean;\n        tagger?: string; // only filled if tagged == true\n        tags: any[];\n      } = {\n        owned: false,\n        numTagged: tagList.length,\n        tagged: false,\n        tags: []\n      };\n\n      if (accountId == commentAccountId) {\n        // You are the tagger\n\n        tagObject.owned = true;\n      }\n\n      if (tagList.map((t: any) => t.account_id).includes(accountId)) {\n        // you got tagged\n\n        tagObject.tagged = true;\n\n        await accounts.getAccountById(commentAccountId).then(\n          (account: any) => {\n            tagObject.tagger = account[0].username;\n          },\n          (err: any) => {}\n        );\n      }\n\n      // add the tags, only include username if you won tag, or its you\n      const tags: any[] = [];\n      for (let tagIndex = 0; tagIndex < tagList.length; tagIndex++) {\n        await accounts.getAccountById(tagList[tagIndex].account_id).then(\n          (account: any) => {\n            tags.push({\n              username:\n                tagObject.owned || accountId == tagList[tagIndex].account_id\n                  ? account[0].username\n                  : '',\n              offset: tagList[tagIndex].offset\n            });\n          },\n          (err: any) => {}\n        );\n      }\n      tagObject.tags = tags;\n\n      // replace the content\n\n      let myindex = 0;\n\n      tagObject.tags.forEach((tag: any) => {\n        ret += commentContent.substring(myindex, tag.offset);\n        ret += '@' + tag.username;\n        myindex += tag.offset;\n      });\n\n      ret += commentContent.substring(myindex, commentContent.length);\n    },\n    (err: any) => {}\n  );\n\n  return ret;\n}\n\n// Links\n\nasync function generateLink(): Promise<string> {\n  // Need to make sure the link isnt already taken\n\n  let link;\n  let exists;\n  do {\n    link = shortid.generate();\n    exists = await comments.linkExists(link);\n  } while (exists);\n\n  return link;\n}\n\n// Location\n\n// is the user in range to make a comment\nasync function inRange(\n  postId: string,\n  latitude: number,\n  longitude: number\n): Promise<boolean> {\n  return posts.getPostByIdNoAccount(postId).then((rows: any) => {\n    // No post with this id\n    if (rows.length < 1) {\n      return false;\n    }\n\n    const post = rows[0];\n    const distance = locations.distanceBetween(\n      post.latitude,\n      post.longitude,\n      latitude,\n      longitude,\n      'm'\n    );\n\n    return distance <= COMMENTS_CONSTANTS.MAX_DISTANCE;\n  });\n}\n"],"file":"comments.js"}