{"version":3,"sources":["../../../src/app/services/locations.ts"],"names":["googleconfig","config","locations","LocationsError","authorization","LOCATIONS_CONSTANTS","roles","checkLocation","req","res","next","authenticated","checkRole","user","owner","admin","guest","accountId","id","latitude","longitude","query","Number","location","body","verifyLocation","then","valid","LocationError","updateLocation","rows","err","account_id","myLatitude","myLongitude","getLatestLocation","length","addLocation","creation_date","Date","valueOf","MAX_TIME_CHANGE","numHours","maxDistance","MAX_DISTANCE_CHANGE","distanceBetween","Math","max","addDistanceToRows","hideDistance","map","row","newRow","distance","MIN_DISTANCE","inRange","lat1","lon1","lat2","lon2","unit","radlat1","PI","radlat2","theta","radtheta","dist","sin","cos","acos","getGeolocation","typeRanks","useTestLocation","Promise","resolve","reject","baseUrl","latlng","parseFloat","filter","forEach","type","index","key","APIKey","url"],"mappings":"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","sourcesContent":["\n\nimport axios from 'axios';\n\n// config\nimport googleconfig from '@config/googlekey';\nimport config from '@config/config';\n\n// db\nimport locations from '@db/locations';\nimport redisClient from '@db/redis';\n\n// error\nimport * as LocationsError from '@exceptions/locations';\n\n// services\nimport authorization from '@services/authorization/authorization';\n\n// constants\nimport { LOCATIONS_CONSTANTS } from '@constants/locations';\nimport roles from '@services/authorization/roles';\n\n// Middleware to call verifyLocation\nconst checkLocation = async (req: any, res: any, next: any) => {\n  // if you aren't logged in then verifying your location doesn't matter\n  if (!req.authenticated) {\n    return next();\n  }\n\n  // allow admins to do whatever\n  if (\n    authorization.checkRole(req.user, [roles.owner, roles.admin, roles.guest])\n  ) {\n    return next();\n  }\n\n  const accountId = req.user.id;\n\n  // For get requests\n\n  let latitude: any = null;\n  let longitude: any = null;\n\n  // for get requests\n  if (req.query) {\n    latitude = Number(req.query.latitude);\n    longitude = Number(req.query.longitude);\n  }\n\n  // for post requests\n  const { location } = req.body;\n\n  if (location) {\n    latitude = location.latitude;\n    longitude = location.longitude;\n  }\n\n  // If there is a location attached to the request, compare to last location\n  if (latitude && longitude) {\n    await verifyLocation(accountId, latitude, longitude).then(\n      (valid: boolean | void) => {\n        if (!valid) {\n          return next(new LocationsError.LocationError(500));\n        } else {\n          // We have a new valid location, update it\n          locations.updateLocation(accountId, latitude, longitude).then(\n            (rows: any) => {\n              return next();\n            },\n            (err: any) => {\n              return next();\n            }\n          );\n        }\n      }\n    );\n  } else {\n    // No location info, so just go next\n    return next();\n  }\n};\n\n// Returns True if the location given is accurate for the user with account_id\nfunction verifyLocation(\n  account_id: string,\n  myLatitude: number,\n  myLongitude: number\n): Promise<boolean | void> {\n  return locations.getLatestLocation(account_id).then(\n    (location: any) => {\n      // No previous info, so add it and return true\n      if (location.length < 1) {\n        return locations.addLocation(account_id, myLatitude, myLongitude).then(\n          (rows: any) => {\n            return true;\n          },\n          (err: any) => {\n            return true;\n          }\n        );\n      } else {\n        const { latitude, longitude, creation_date } = location[0];\n\n        // The max time delay has passed\n        if (\n          new Date().valueOf() >=\n          new Date(\n            new Date(creation_date).valueOf() +\n              LOCATIONS_CONSTANTS.MAX_TIME_CHANGE * 3600000\n          ).valueOf()\n        ) {\n          return true;\n        } else {\n          const numHours =\n            (new Date().valueOf() - new Date(creation_date).valueOf()) /\n            3600000;\n\n          const maxDistance =\n            LOCATIONS_CONSTANTS.MAX_DISTANCE_CHANGE * numHours;\n\n          // TODO: fix Math.max(1) to be a constant\n          return (\n            distanceBetween(\n              myLatitude,\n              myLongitude,\n              latitude,\n              longitude,\n              'M'\n            ) <= Math.max(1, maxDistance)\n          );\n        }\n      }\n    },\n    (err: any) => {\n      return true;\n    }\n  );\n}\n\nfunction addDistanceToRows(\n  rows: any[],\n  latitude: number,\n  longitude: number,\n  hideDistance: boolean\n): any[] {\n  return rows.map((row: any) => {\n    const newRow = row;\n    if (latitude && longitude) {\n      const distance = distanceBetween(\n        latitude,\n        longitude,\n        row.latitude,\n        row.longitude,\n        'M'\n      );\n      newRow.distance = hideDistance\n        ? Math.max(LOCATIONS_CONSTANTS.MIN_DISTANCE, distance)\n        : distance;\n      newRow.inRange = newRow.distance <= 10;\n    } else {\n      newRow.inRange = false;\n    }\n    delete newRow.latitude;\n    delete newRow.longitude;\n    return newRow;\n  });\n}\n\nfunction distanceBetween(\n  lat1: number,\n  lon1: number,\n  lat2: number,\n  lon2: number,\n  unit: string\n): number {\n  if (lat1 == lat2 && lon1 == lon2) {\n    return 0;\n  } else {\n    const radlat1 = (Math.PI * lat1) / 180;\n    const radlat2 = (Math.PI * lat2) / 180;\n    const theta = lon1 - lon2;\n    const radtheta = (Math.PI * theta) / 180;\n    let dist =\n      Math.sin(radlat1) * Math.sin(radlat2) +\n      Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);\n    if (dist > 1) {\n      dist = 1;\n    }\n    dist = Math.acos(dist);\n    dist = (dist * 180) / Math.PI;\n    dist = dist * 60 * 1.1515;\n    if (unit == 'K') {\n      dist = dist * 1.609344;\n    }\n    if (unit == 'N') {\n      dist = dist * 0.8684;\n    }\n    return dist;\n  }\n}\n\nfunction getGeolocation(latitude: string, longitude: string): Promise<string> {\n  // In order the most preferred location type\n  // Nothing with a proper address\n  const typeRanks = [\n    'point_of_interest',\n    'landmark',\n    'establishment',\n    'premise',\n    'transit_station',\n    'university',\n    'neighborhood',\n    'locality',\n    'country'\n  ];\n\n  // for testing purposes\n  if (config.useTestLocation) {\n    return new Promise((resolve, reject) => {\n      resolve('TEST');\n    });\n  }\n\n  const baseUrl = 'https://maps.googleapis.com/maps/api/geocode/json?';\n  const latlng = 'latlng=' + parseFloat(latitude) + ',' + parseFloat(longitude);\n  let filter = '&result_type=';\n\n  typeRanks.forEach((type: string, index: number) => {\n    filter += type;\n    if (index !== typeRanks.length - 1) {\n      filter += '|';\n    }\n  });\n\n  const key = '&key=' + googleconfig.APIKey;\n\n  const url = baseUrl + latlng + filter + key;\n\n  return new Promise((resolve, reject) => {\n    resolve('TEST');\n  })\n\n  // TODO: FIX THIS!!!!\n\n  // eslint-disable-next-line no-async-promise-executor\n  // return new Promise(async (resolve, reject) => {\n  //   // check redis cache first\n  //   await redisClient.GEOSEARCH(\n  //     'geocodes',\n  //     longitude,\n  //     latitude,\n  //     '25',\n  //     'm',\n  //     'WITHCOORD',\n  //     'WITHDIST',\n  //     'ASC',\n  //     async (err: any, results: any[]) => {\n  //       if (results.length > 0) {\n  //         // check if the entry needs to be removed from cache due to time expires\n  //         const locationName = results[0][0];\n  //         await redisClient.zScore(\n  //           'geocodes_expires',\n  //           locationName,\n  //           async (err: any, expiresTimestamp: any) => {\n  //             if (expiresTimestamp >= new Date().getTime()) {\n  //               await redisClient.zem('geocodes_expires', locationName);\n  //               await redisClient.zrem('geocodes', locationName);\n  //             } else {\n  //               return resolve(locationName);\n  //             }\n  //           }\n  //         );\n  //       }\n  //     }\n  //   );\n\n  //   axios(url, (error: any, response: any, body: any) => {\n  //     if (error) {\n  //       return reject(error);\n  //     }\n\n  //     const res = JSON.parse(body);\n\n  //     // No place\n  //     if (res.results.length === 0) {\n  //       return resolve('');\n  //     }\n\n  //     // expire time of the address\n  //     const date = new Date();\n  //     const geocodeExpiresIn = 7; // days\n  //     date.setDate(date.getDate() + geocodeExpiresIn);\n  //     const expireTimestamp = date.getTime();\n\n  //     // possible address\n  //     const possibleAddresses: any[] = [];\n\n  //     res.results.forEach((place: any) => {\n  //       place.address_components.forEach((address: any) => {\n  //         typeRanks.forEach((typeAddress: string) => {\n  //           if (address.types.includes(typeAddress)) {\n  //             possibleAddresses.push([address.long_name, typeAddress]);\n  //           }\n  //         });\n  //       });\n  //     });\n\n  //     // take the first highest of possible\n  //     typeRanks.forEach((typeAddress: string) => {\n  //       possibleAddresses.forEach((possible: any) => {\n  //         if (possible[1] === typeAddress) {\n  //           // add to redis and resolve\n  //           redisClient.zAdd('geocodes_expires', expireTimestamp, possible[0]);\n  //           redisClient.geoAdd('geocodes', longitude, latitude, possible[0]);\n  //           return resolve(possible[0]);\n  //         }\n  //       });\n  //     });\n\n  //     // nothing\n  //     return resolve('');\n  //   });\n  // });\n}\n\nexport default {\n  checkLocation,\n  verifyLocation,\n  distanceBetween,\n  getGeolocation,\n  addDistanceToRows\n};"],"file":"locations.js"}